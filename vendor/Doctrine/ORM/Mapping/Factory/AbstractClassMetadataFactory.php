<?php

declare(strict_types=1);

namespace Doctrine\ORM\Mapping\Factory;

use Doctrine\Common\Persistence\Mapping\ClassMetadataFactory;
use Doctrine\DBAL\Platforms\AbstractPlatform;
use Doctrine\ORM\Configuration\MetadataConfiguration;
use Doctrine\ORM\Mapping\ClassMetadata;
use Doctrine\ORM\Mapping\ClassMetadataBuildingContext;
use Doctrine\ORM\Mapping\Driver\MappingDriver;
use Doctrine\ORM\Mapping\Factory\Strategy\ConditionalFileWriterClassMetadataGeneratorStrategy;
use Doctrine\ORM\Reflection\ReflectionService;
use Doctrine\ORM\Reflection\RuntimeReflectionService;
use Doctrine\ORM\Utility\StaticClassNameConverter;
use InvalidArgumentException;
use function array_reverse;

/**
 * AbstractClassMetadataFactory is the base of ClassMetadata object creation that contain all the metadata mapping
 * information of a class which describes how a class should be mapped to a relational database.
 */
abstract class AbstractClassMetadataFactory implements ClassMetadataFactory
{
    /**
     * Never autogenerate a class metadata and rely that it was generated by some process before deployment.
     *
     * @deprecated please use @see \Doctrine\ORM\Mapping\Factory\AbstractClassMetadataFactory::AUTOGENERATE_FILE_NOT_EXISTS
     */
    public const AUTOGENERATE_NEVER = 0;

    /**
     * Always generates a new class metadata in every request. This is only sane during development.
     *
     * @deprecated please use @see \Doctrine\ORM\Mapping\Factory\AbstractClassMetadataFactory::AUTOGENERATE_FILE_NOT_EXISTS
     */
    public const AUTOGENERATE_ALWAYS = 1;

    /**
     * Autogenerate the class metadata when the file does not exist.
     * This strategy causes a file exists call whenever any metadata is used the first time in a request.
     */
    public const AUTOGENERATE_FILE_NOT_EXISTS = 2;

    /** @var ClassMetadataDefinitionFactory */
    protected $definitionFactory;

    /** @var MappingDriver */
    protected $mappingDriver;

    /** @var AbstractPlatform */
    protected $targetPlatform;

    /** @var NamingStrategy */
    protected $namingStrategy;

    /** @var ClassMetadataDefinition[] */
    private $definitions = [];

    /** @var ClassMetadata[] */
    private $loaded = [];

    public function __construct(MetadataConfiguration $configuration)
    {
        $mappingDriver  = $configuration->getMappingDriver();
        $resolver       = $configuration->getResolver();
        $targetPlatform = $configuration->getTargetPlatform();
        $namingStrategy = $configuration->getNamingStrategy();
        //$autoGenerate      = $configuration->getAutoGenerate();

        $generator         = new ClassMetadataGenerator($mappingDriver);
        $generatorStrategy = new ConditionalFileWriterClassMetadataGeneratorStrategy($generator);
        $definitionFactory = new ClassMetadataDefinitionFactory($resolver, $generatorStrategy);

        $this->mappingDriver     = $mappingDriver;
        $this->definitionFactory = $definitionFactory;
        $this->targetPlatform    = $targetPlatform;
        $this->namingStrategy    = $namingStrategy;
    }

    /**
     * {@inheritdoc}
     *
     * @throws InvalidArgumentException
     */
    public function getAllMetadata() : array
    {
        $metadata = [];

        foreach ($this->mappingDriver->getAllClassNames() as $className) {
            $metadata[] = $this->getMetadataFor($className);
        }

        return $metadata;
    }

    /**
     * {@inheritdoc}
     */
    public function getMetadataFor($className)
    {
        $entityClassName = StaticClassNameConverter::getRealClass($className);

        if (isset($this->loaded[$entityClassName])) {
            return $this->loaded[$entityClassName];
        }

        $metadataBuildingContext = new ClassMetadataBuildingContext(
            $this,
            new RuntimeReflectionService(),
            $this->targetPlatform,
            $this->namingStrategy
        );

        $parentClassMetadata = null;
        $parentClassNameList = $this->getParentClassNameList($entityClassName);

        $parentClassNameList[] = $entityClassName;

        foreach ($parentClassNameList as $parentClassName) {
            if (isset($this->loaded[$parentClassName])) {
                $parentClassMetadata = $this->loaded[$parentClassName];

                continue;
            }

            $definition = $this->getOrCreateClassMetadataDefinition(
                $parentClassName,
                $parentClassMetadata,
                $metadataBuildingContext
            );

            $parentClassMetadata = $this->loaded[$parentClassName] = $this->createClassMetadata($definition);
        }

        $metadataBuildingContext->validate();

        return $this->loaded[$entityClassName];
    }

    /**
     * {@inheritdoc}
     */
    public function hasMetadataFor($className) : bool
    {
        return isset($this->loaded[$className]);
    }

    /**
     * {@inheritdoc}
     */
    public function setMetadataFor($className, $class) : void
    {
        $this->loaded[$className] = $class;
    }

    /**
     * {@inheritdoc}
     */
    public function isTransient($className) : bool
    {
        $entityClassName = StaticClassNameConverter::getRealClass($className);

        return $this->mappingDriver->isTransient($entityClassName);
    }

    protected function createClassMetadata(ClassMetadataDefinition $definition) : ClassMetadata
    {
        /** @var ClassMetadata $classMetadata */
        $metadataFqcn  = $definition->metadataClassName;
        $classMetadata = new $metadataFqcn($definition->parentClassMetadata);

        $classMetadata->wakeupReflection($this->getReflectionService());

        return $classMetadata;
    }

    /**
     * Create a class metadata definition for the given class name.
     */
    private function getOrCreateClassMetadataDefinition(
        string $className,
        ?ClassMetadata $parent,
        ClassMetadataBuildingContext $metadataBuildingContext
    ) : ClassMetadataDefinition {
        if (! isset($this->definitions[$className])) {
            $this->definitions[$className] = $this->definitionFactory->build($className, $parent, $metadataBuildingContext);
        }

        return $this->definitions[$className];
    }

    /**
     * @return string[]
     *
     * @throws InvalidArgumentException
     */
    private function getParentClassNameList(string $className) : array
    {
        $reflectionService   = $this->getReflectionService();
        $parentClassNameList = [];

        foreach (array_reverse($reflectionService->getParentClasses($className)) as $parentClassName) {
            if ($this->mappingDriver->isTransient($parentClassName)) {
                continue;
            }

            $parentClassNameList[] = $parentClassName;
        }

        return $parentClassNameList;
    }

    abstract protected function getReflectionService() : ReflectionService;
}
